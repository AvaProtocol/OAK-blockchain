use core::marker::PhantomData;

use codec::{Decode, Encode};
use frame_support::{
	traits::{Get, OnRuntimeUpgrade},
	weights::Weight,
	Twox64Concat,
};
use scale_info::TypeInfo;
use xcm::latest::prelude::*;

use crate::{Config, XcmAssetConfig, XcmFlow};

#[cfg(feature = "std")]
use serde::{Deserialize, Serialize};
#[cfg(feature = "try-runtime")]
use sp_std::vec::Vec;

/// Pre-migrations storage struct
#[derive(Clone, Copy, Debug, Encode, Decode, PartialEq, TypeInfo)]
#[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
pub struct OldXcmAssetConfig {
	pub fee_per_second: u128,
	/// The UnitWeightCost of a single instruction on the target chain
	pub instruction_weight: u64,
	/// The desired instruction flow for the target chain
	pub flow: XcmFlow,
}

impl From<OldXcmAssetConfig> for XcmAssetConfig {
	fn from(data: OldXcmAssetConfig) -> Self {
		XcmAssetConfig {
			fee_per_second: data.fee_per_second,
			instruction_weight: Weight::from_ref_time(data.instruction_weight),
			flow: data.flow,
		}
	}
}

#[frame_support::storage_alias]
pub type DestinationAssetConfig =
	StorageMap<XcmpHandler, Twox64Concat, MultiLocation, OldXcmAssetConfig>;

pub struct UpgradeWeightStruct<T>(PhantomData<T>);
impl<T: Config> OnRuntimeUpgrade for UpgradeWeightStruct<T> {
	fn on_runtime_upgrade() -> Weight {
		log::info!(target: "xcmp-handler", "UpgradeWeightStruct migration");

		let mut migrated_asset_configs = 0u32;
		DestinationAssetConfig::iter().for_each(|(location, asset_config)| {
			let migrated_asset_config: XcmAssetConfig = asset_config.into();
			crate::DestinationAssetConfig::<T>::insert(location, migrated_asset_config);
			migrated_asset_configs += 1;
		});

		log::info!(target: "xcmp-handler", "UpgradeWeightStruct successful! Migrated {} object.", migrated_asset_configs);

		T::DbWeight::get()
			.reads_writes(migrated_asset_configs as u64, migrated_asset_configs as u64)
	}

	#[cfg(feature = "try-runtime")]
	fn pre_upgrade() -> Result<Vec<u8>, &'static str> {
		let prev_count = DestinationAssetConfig::iter().count() as u32;
		Ok(prev_count.encode())
	}

	#[cfg(feature = "try-runtime")]
	fn post_upgrade(prev_count: Vec<u8>) -> Result<(), &'static str> {
		let prev_count: u32 = Decode::decode(&mut prev_count.as_slice())
			.expect("the state parameter should be something that was generated by pre_upgrade");
		let post_count = crate::DestinationAssetConfig::<T>::iter().count() as u32;
		assert!(post_count == prev_count);

		log::info!(
			target: "xcmp-handler",
			"UpgradeWeightStruct try-runtime checks complete"
		);

		Ok(())
	}
}
